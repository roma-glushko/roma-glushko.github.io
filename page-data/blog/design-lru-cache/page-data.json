{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/design-lru-cache/","result":{"data":{"markdownRemark":{"html":"<p>While preparing for coding interviews, I went through a large number of algorithmic challenges. I found particularly interesting one subset of problems - challenges related to designing some tools that we all use and rarely stop and think about how they work.</p>\n<p>In this article, we are going to take a look at the Least Recently Used (LRU) cache.</p>\n<p><strong>Least Recently Used Cache</strong> is a key-value storage that has some capacity and a specific key eviction policy. Whenever it's specified in Gb, percentage of RAM or number of keys, the cache capacity is useful to prevent the storage from overflowing the available memory resources and shutting down unexpectedly.</p>\n<p>But what can we do when we are about to reach our capacity limits?</p>\n<p>This is where eviction is helpful. In the case of LRU policy, we can just <strong>remove key-values that were not accessed for the longest time</strong> a.k.a least-recently-used items. This is a pretty natural things to do and it's commonly used in such popular key-value storages as Redis.</p>\n<p>Another part to pay attention to is cache. <strong>Cache</strong> is a kind of storage that is usually <strong>optimized for reading and retrieving information</strong> that would be time- or resource-consuming to calculate or collect without the cache.</p>\n<h2 id=\"problem-framing\" style=\"position:relative;\"><a href=\"#problem-framing\" aria-label=\"problem framing permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Problem Framing</h2>\n<p>Now we have a broad context around LRU cache use cases and we are ready to formulate the challenge.</p>\n<p>We want to design a <strong>class that represents LRU cache and has the following APIs</strong>:</p>\n<ul>\n<li><code class=\"language-text\">LRUCache(capacity: int)</code> class should be initialized with a capacity of the storage where the capacity is simply a number of keys that storage can hold.</li>\n<li><code class=\"language-text\">get(key: int)</code> method which can retrieve the value by key in constant time (O(1)).</li>\n<li><code class=\"language-text\">put(key: int, value: int)</code> method which stores key-value pair in the cache in constant time (O(1)). If a key is already in the storage, we need to replace its value with a new one. <code class=\"language-text\">put()</code> method should be constrained by capacity value and should not exceed it. When capacity restriction is about to be reached, we need to evict the least-recently-used item to put a new key-value pair to the storage.</li>\n</ul>\n<p>Since we are trying to design a cache storage, pretty much every operation should be done in <strong>constant time execution on average</strong> to keep it practically useful. This means that key eviction should also happen in O(1) complexity range.</p>\n<h2 id=\"brainstorm-solutions\" style=\"position:relative;\"><a href=\"#brainstorm-solutions\" aria-label=\"brainstorm solutions permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Brainstorm Solutions</h2>\n<p>When I think about cache, <strong>dictionaries or hashtables</strong> come to my mind.</p>\n<p><img src=\"/29e84368c716f70b2bb4e5dd5bd93402/cache-based-on-hashtable.svg\" alt=\"Cache based on a hashtable\" loading=\"lazy\">\n          </p>\n<div class=\"image-title\">Cache based on a hashtable</div>\n<p>Hashtables allow to <strong>read and write key-value pairs in constant time with high probability</strong>.</p>\n<p>The problem with dictionaries is that they usually don't guarantee order in which they manage keys. So we don't have a way to quickly remove least-recently-used items. We could introduce a notion of last-used timestamps for each item in the hashtable and update these timestamps during accessing the keys in <code class=\"language-text\">get()</code> method.</p>\n<p><img src=\"/4181faf11cec6c2dc73707b3ebfec8be/cache-based-on-hashtable-with-timestamps.svg\" alt=\"Timestamps won\" t=\"\" help=\"\" us=\"\" because=\"\" of=\"\" sequential=\"\" search=\"\" we=\"\" need=\"\" to=\"\" do=\"\" on=\"\" the=\"\" hashtable'=\"\" loading=\"lazy\">\n          </p>\n<div class=\"image-title\">Timestamps won't help us because of sequential search we need to do on the hashtable</div>\n<p>However, it would still <strong>take us O(n) in order to find items to evict</strong> by timestamps. It's too time-consuming to meet our requirements.</p>\n<p>Let's not get hung up on hashtables. The problem with tracking item usage can be solved with <strong>linked lists</strong>.</p>\n<p><img src=\"/b823d5ec2c9b887180d6ba5d7ce67886/cache-based-on-linked-list.svg\" alt=\"Cache based a linked list\" loading=\"lazy\">\n          </p>\n<div class=\"image-title\">Cache based a linked list</div>\n<p>With linked lists, we could <strong>keep track of item usages in constant time</strong>. We could simply move the item we currently access to the top of the list. In a natural way, <strong>least used items end up being at the very bottom of the list</strong> and we would get a list ordered by item usage as we go. Since we need to relink our items, it would be helpful to have reference to the previous and next items on the list.</p>\n<p>Nevertheless, linked lists don't meet our requirements completely. It would <strong>take us O(n) in order to find and retrieve item by key</strong>. This is a sad complexity for cache storages.</p>\n<p>To sum up, hashtables luck the advantages of linked lists and linked lists luck advantages of hashtables. We find to <strong>find a way to combine hashtables and linked lists</strong> such that we meet our LRU cache requirements.</p>\n<h2 id=\"design-solution\" style=\"position:relative;\"><a href=\"#design-solution\" aria-label=\"design solution permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Design Solution</h2>\n<p>After a little bit of thinking, it may click that we can <strong>map our keys not to the values directly, but to the linked list nodes</strong> that represent these values. Mapping keys to list nodes means that the <strong>dictionary will hold node references</strong> that don't depend on node positions in the list itself. So we would be able to <strong>rearrange list items without a need to remap</strong> them in the dictionary.</p>\n<p><img src=\"/fb18912af9367d01561f7c6906a84459/lru-cache-architecture.svg\" alt=\"LRU Cache Architecture\" loading=\"lazy\">\n          </p>\n<div class=\"image-title\">LRU cache architecture based on combination of hashtable and linked list</div>\n<h2 id=\"implement-solution\" style=\"position:relative;\"><a href=\"#implement-solution\" aria-label=\"implement solution permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Implement Solution</h2>\n<p>Let's start our implementation from create APIs which we want to see in the linked list:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> Dict<span class=\"token punctuation\">,</span> Optional\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    Linked List Node. Contains key-value pair and links to neighbor elements.\n    \"\"\"</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> prev<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">next</span><span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> key\n        self<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> value\n\n        self<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> prev\n        self<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">next</span>\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LinkedList</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    Linked List. Represents usage history of cache items\n    \"\"\"</span>\n    head<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n    tail<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Node<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">add_to_head</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">:</span> Node<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Add node to the very top of the list\n        \"\"\"</span>\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>head <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            item<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head\n            self<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> item\n\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>tail <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> item\n\n        self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> item\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">unlink</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">:</span> Node<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Remove references to the node from other nodes on the list\n        \"\"\"</span>\n        <span class=\"token keyword\">if</span> item <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span>\n\n        prev_item<span class=\"token punctuation\">:</span> Node <span class=\"token operator\">=</span> item<span class=\"token punctuation\">.</span>prev\n        next_item<span class=\"token punctuation\">:</span> Node <span class=\"token operator\">=</span> item<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\n\n        <span class=\"token comment\"># unlink the item node:</span>\n        <span class=\"token comment\"># link prev and next items</span>\n        <span class=\"token comment\"># removing referenced to the current item node</span>\n        <span class=\"token keyword\">if</span> prev_item <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            prev_item<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> next_item\n\n        <span class=\"token keyword\">if</span> next_item <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            next_item<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> prev_item\n\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">==</span> item<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># item was the first element in the list</span>\n            self<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> next_item\n\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>tail <span class=\"token operator\">==</span> item<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># item was the last element in the list</span>\n            self<span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> prev_item\n\n        <span class=\"token comment\"># make sure that the item itself doesn't have references to other nodes</span>\n        item<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\n        item<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span></code></pre></div>\n<p>All node manipulations (e.g. <code class=\"language-text\">add_to_head()</code>, <code class=\"language-text\">unlink()</code> methods) operates in constant time and doesn't depend on the size of the linked list.</p>\n<p>Having a linked list implemented, we can actually code the idea of LRU architecture we came up with:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">LRUCache</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    Implementation of cache storage with LRU eviction policy\n    \"\"\"</span>\n    capacity<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span>\n    cache_map<span class=\"token punctuation\">:</span> Dict<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> Node<span class=\"token punctuation\">]</span>\n    history<span class=\"token punctuation\">:</span> LinkedList\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> capacity<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity\n        self<span class=\"token punctuation\">.</span>cache_map <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n        self<span class=\"token punctuation\">.</span>history <span class=\"token operator\">=</span> LinkedList<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Retrieve value by its key or -1 otherwise\n        \"\"\"</span>\n        <span class=\"token keyword\">if</span> key <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n\n        value_node<span class=\"token punctuation\">:</span> Node <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>head <span class=\"token operator\">!=</span> value_node<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># make item the most recently used</span>\n            self<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>value_node<span class=\"token punctuation\">)</span>\n            self<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>add_to_head<span class=\"token punctuation\">(</span>value_node<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> value_node<span class=\"token punctuation\">.</span>value\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Add a new key-value pair to the cache.\n        If key exists, replace its value by a new one.\n        If capacity is reached, evict the LRU item and insert a new pair\n        \"\"\"</span>\n        value_node<span class=\"token punctuation\">:</span> Node <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> key <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>remove_item<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> self<span class=\"token punctuation\">.</span>capacity<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\"># no space left, needs to evict the least recently used item</span>\n            self<span class=\"token punctuation\">.</span>evict_least_recent_item<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n        self<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>add_to_head<span class=\"token punctuation\">(</span>value_node<span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value_node\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">evict_least_recent_item</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Evict the least recently used item\n        \"\"\"</span>\n        lru_item<span class=\"token punctuation\">:</span> Node <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>tail\n\n        <span class=\"token keyword\">if</span> lru_item <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span>\n\n        self<span class=\"token punctuation\">.</span>remove_item<span class=\"token punctuation\">(</span>lru_item<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">remove_item</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> item<span class=\"token punctuation\">:</span> Node<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token triple-quoted-string string\">\"\"\"\n        Remove item represented by node from the map and the list\n        \"\"\"</span>\n        self<span class=\"token punctuation\">.</span>history<span class=\"token punctuation\">.</span>unlink<span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">del</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>item<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">]</span>\n        <span class=\"token keyword\">del</span> item\n</code></pre></div>\n<p>The <code class=\"language-text\">get()</code> and <code class=\"language-text\">put()</code> methods only rely on methods that run in constant time, so our implementation has <strong>constant running time on average</strong>. Just like we have required earlier. In order to get here, we consume <code class=\"language-text\">O(2N)</code> memory to build a map and a linked list.</p>\n<p>This solution is common and can be implemented in any general purpose language. Specifically speaking about Python, it provides <code class=\"language-text\">OrderedDict</code> data structure that helps to implement LRU cache in a much <strong>more concise way</strong>. Let's take a look:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> OrderedDict\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">LRUCache</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    This is alternative implementation of LRU cache based on OrderedDict\n    \"\"\"</span>\n    capacity<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span>\n    cache_map<span class=\"token punctuation\">:</span> OrderedDict\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> capacity<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>capacity <span class=\"token operator\">=</span> capacity\n        self<span class=\"token punctuation\">.</span>cache_map <span class=\"token operator\">=</span> OrderedDict<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> key <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\n\n        value <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n        self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">.</span>move_to_end<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n\n        <span class=\"token keyword\">return</span> value\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> key <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value\n            self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">.</span>move_to_end<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> self<span class=\"token punctuation\">.</span>capacity<span class=\"token punctuation\">:</span>\n            lru_key <span class=\"token operator\">=</span> <span class=\"token builtin\">next</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">iter</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">del</span> self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>lru_key<span class=\"token punctuation\">]</span>\n\n        self<span class=\"token punctuation\">.</span>cache_map<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> value</code></pre></div>\n<p>OrderedDict seems to be introduced specifically to implement <a href=\"https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes\" target=\"_blank\" rel=\"noopener noreferrer\">LRU cache</a>. We may expect that under the hood it has been implemented in a similar way to what we came up with since the runtime and memory usage are pretty the same for both versions.</p>\n<h2 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>Summary</h2>\n<p>We went through designing and implementing our own LRU cache. We combined the advantages of hashtables and linked list and built efficient cache storage on top of them.</p>\n<p>Besides being an interesting task, the problem is a common question in the coding interviews. So if you are preparing right now, feel free to implement LRU cache yourself on Leetcode.</p>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg class=\"anchor-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z\"></path></svg></a>References</h2>\n<ul>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/roma-glushko/leetcode-solutions/blob/master/src/design/lru_cache.py\">Implementation on GitHub</a></li>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://leetcode.com/problems/lru-cache/\">[LeetCode] 146. LRU Cache</a></li>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850\">Cracking the Coding Interview book by Gayle MacDowell</a></li>\n</ul>","timeToRead":7,"rawMarkdownBody":"\nWhile preparing for coding interviews, I went through a large number of algorithmic challenges. I found particularly interesting one subset of problems - challenges related to designing some tools that we all use and rarely stop and think about how they work.\n\nIn this article, we are going to take a look at the Least Recently Used (LRU) cache.\n\n**Least Recently Used Cache** is a key-value storage that has some capacity and a specific key eviction policy. Whenever it's specified in Gb, percentage of RAM or number of keys, the cache capacity is useful to prevent the storage from overflowing the available memory resources and shutting down unexpectedly.\n\nBut what can we do when we are about to reach our capacity limits?\n\nThis is where eviction is helpful. In the case of LRU policy, we can just **remove key-values that were not accessed for the longest time** a.k.a least-recently-used items. This is a pretty natural things to do and it's commonly used in such popular key-value storages as Redis.\n\nAnother part to pay attention to is cache. **Cache** is a kind of storage that is usually **optimized for reading and retrieving information** that would be time- or resource-consuming to calculate or collect without the cache.\n\n## Problem Framing\n\nNow we have a broad context around LRU cache use cases and we are ready to formulate the challenge.\n\nWe want to design a **class that represents LRU cache and has the following APIs**:\n\n- `LRUCache(capacity: int)` class should be initialized with a capacity of the storage where the capacity is simply a number of keys that storage can hold.\n- `get(key: int)` method which can retrieve the value by key in constant time (O(1)).\n- `put(key: int, value: int)` method which stores key-value pair in the cache in constant time (O(1)). If a key is already in the storage, we need to replace its value with a new one. `put()` method should be constrained by capacity value and should not exceed it. When capacity restriction is about to be reached, we need to evict the least-recently-used item to put a new key-value pair to the storage.\n\nSince we are trying to design a cache storage, pretty much every operation should be done in **constant time execution on average** to keep it practically useful. This means that key eviction should also happen in O(1) complexity range.\n\n## Brainstorm Solutions\n\nWhen I think about cache, **dictionaries or hashtables** come to my mind.\n\n![Cache based on a hashtable](./img/cache-based-on-hashtable.svg \"Cache based on a hashtable\")\n\n<div class=\"image-title\">Cache based on a hashtable</div>\n\nHashtables allow to **read and write key-value pairs in constant time with high probability**.\n\nThe problem with dictionaries is that they usually don't guarantee order in which they manage keys. So we don't have a way to quickly remove least-recently-used items. We could introduce a notion of last-used timestamps for each item in the hashtable and update these timestamps during accessing the keys in `get()` method.\n\n![Timestamps won't help us because of sequential search we need to do on the hashtable](./img/cache-based-on-hashtable-with-timestamps.svg \"Cache as a hashtable\")\n\n<div class=\"image-title\">Timestamps won't help us because of sequential search we need to do on the hashtable</div>\n\nHowever, it would still **take us O(n) in order to find items to evict** by timestamps. It's too time-consuming to meet our requirements.\n\nLet's not get hung up on hashtables. The problem with tracking item usage can be solved with **linked lists**.\n\n![Cache based a linked list](./img/cache-based-on-linked-list.svg \"Cache based a linked list\")\n\n<div class=\"image-title\">Cache based a linked list</div>\n\nWith linked lists, we could **keep track of item usages in constant time**. We could simply move the item we currently access to the top of the list. In a natural way, **least used items end up being at the very bottom of the list** and we would get a list ordered by item usage as we go. Since we need to relink our items, it would be helpful to have reference to the previous and next items on the list.\n\nNevertheless, linked lists don't meet our requirements completely. It would **take us O(n) in order to find and retrieve item by key**. This is a sad complexity for cache storages.\n\nTo sum up, hashtables luck the advantages of linked lists and linked lists luck advantages of hashtables. We find to **find a way to combine hashtables and linked lists** such that we meet our LRU cache requirements.\n\n## Design Solution\n\nAfter a little bit of thinking, it may click that we can **map our keys not to the values directly, but to the linked list nodes** that represent these values. Mapping keys to list nodes means that the **dictionary will hold node references** that don't depend on node positions in the list itself. So we would be able to **rearrange list items without a need to remap** them in the dictionary.\n\n![LRU Cache Architecture](./img/lru-cache-architecture.svg \"LRU Cache Architecture\")\n\n<div class=\"image-title\">LRU cache architecture based on combination of hashtable and linked list</div>\n\n## Implement Solution\n\nLet's start our implementation from create APIs which we want to see in the linked list:\n\n```python\nfrom typing import Dict, Optional\n\n\nclass Node:\n    \"\"\"\n    Linked List Node. Contains key-value pair and links to neighbor elements.\n    \"\"\"\n    def __init__(self, key: int, value: int, prev=None, next=None):\n        self.key: int = key\n        self.value: int = value\n\n        self.prev: Optional[Node] = prev\n        self.next: Optional[Node] = next\n\n\nclass LinkedList:\n    \"\"\"\n    Linked List. Represents usage history of cache items\n    \"\"\"\n    head: Optional[Node] = None\n    tail: Optional[Node] = None\n\n    def add_to_head(self, item: Node) -> None:\n        \"\"\"\n        Add node to the very top of the list\n        \"\"\"\n        if self.head is not None:\n            item.next = self.head\n            self.head.prev = item\n\n        if self.tail is None:\n            self.tail = item\n\n        self.head = item\n\n    def unlink(self, item: Node) -> None:\n        \"\"\"\n        Remove references to the node from other nodes on the list\n        \"\"\"\n        if item is None:\n            return\n\n        prev_item: Node = item.prev\n        next_item: Node = item.next\n\n        # unlink the item node:\n        # link prev and next items\n        # removing referenced to the current item node\n        if prev_item is not None:\n            prev_item.next = next_item\n\n        if next_item is not None:\n            next_item.prev = prev_item\n\n        if self.head == item:\n            # item was the first element in the list\n            self.head = next_item\n\n        if self.tail == item:\n            # item was the last element in the list\n            self.tail = prev_item\n\n        # make sure that the item itself doesn't have references to other nodes\n        item.prev = None\n        item.next = None\n```\n\nAll node manipulations (e.g. `add_to_head()`, `unlink()` methods) operates in constant time and doesn't depend on the size of the linked list.\n\nHaving a linked list implemented, we can actually code the idea of LRU architecture we came up with:\n\n```python\nclass LRUCache:\n    \"\"\"\n    Implementation of cache storage with LRU eviction policy\n    \"\"\"\n    capacity: int\n    cache_map: Dict[int, Node]\n    history: LinkedList\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache_map = {}\n        self.history = LinkedList()\n\n    def get(self, key: int) -> int:\n        \"\"\"\n        Retrieve value by its key or -1 otherwise\n        \"\"\"\n        if key not in self.cache_map:\n            return -1\n\n        value_node: Node = self.cache_map[key]\n\n        if self.history.head != value_node:\n            # make item the most recently used\n            self.history.unlink(value_node)\n            self.history.add_to_head(value_node)\n\n        return value_node.value\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"\n        Add a new key-value pair to the cache.\n        If key exists, replace its value by a new one.\n        If capacity is reached, evict the LRU item and insert a new pair\n        \"\"\"\n        value_node: Node = Node(key, value)\n\n        if key in self.cache_map:\n            self.remove_item(self.cache_map[key])\n\n        if len(self.cache_map) >= self.capacity:\n            # no space left, needs to evict the least recently used item\n            self.evict_least_recent_item()\n\n        self.history.add_to_head(value_node)\n        self.cache_map[key] = value_node\n\n    def evict_least_recent_item(self) -> None:\n        \"\"\"\n        Evict the least recently used item\n        \"\"\"\n        lru_item: Node = self.history.tail\n\n        if lru_item is None:\n            return\n\n        self.remove_item(lru_item)\n\n    def remove_item(self, item: Node) -> None:\n        \"\"\"\n        Remove item represented by node from the map and the list\n        \"\"\"\n        self.history.unlink(item)\n\n        del self.cache_map[item.key]\n        del item\n\n```\n\nThe `get()` and `put()` methods only rely on methods that run in constant time, so our implementation has **constant running time on average**. Just like we have required earlier. In order to get here, we consume `O(2N)` memory to build a map and a linked list.\n\nThis solution is common and can be implemented in any general purpose language. Specifically speaking about Python, it provides `OrderedDict` data structure that helps to implement LRU cache in a much **more concise way**. Let's take a look:\n\n```python\nfrom collections import OrderedDict\n\n\nclass LRUCache:\n    \"\"\"\n    This is alternative implementation of LRU cache based on OrderedDict\n    \"\"\"\n    capacity: int\n    cache_map: OrderedDict\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache_map = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache_map:\n            return -1\n\n        value = self.cache_map[key]\n        self.cache_map.move_to_end(key)\n\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache_map:\n            self.cache_map[key] = value\n            self.cache_map.move_to_end(key)\n            return\n\n        if len(self.cache_map) >= self.capacity:\n            lru_key = next(iter(self.cache_map))\n            del self.cache_map[lru_key]\n\n        self.cache_map[key] = value\n```\n\nOrderedDict seems to be introduced specifically to implement [LRU cache](https://docs.python.org/3/library/collections.html#ordereddict-examples-and-recipes). We may expect that under the hood it has been implemented in a similar way to what we came up with since the runtime and memory usage are pretty the same for both versions.\n\n## Summary\n\nWe went through designing and implementing our own LRU cache. We combined the advantages of hashtables and linked list and built efficient cache storage on top of them.\n\nBesides being an interesting task, the problem is a common question in the coding interviews. So if you are preparing right now, feel free to implement LRU cache yourself on Leetcode.\n\n## References\n\n- <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/roma-glushko/leetcode-solutions/blob/master/src/design/lru_cache.py\">Implementation on GitHub</a>\n- <a target=\"_blank\" rel=\"noopener\" href=\"https://leetcode.com/problems/lru-cache/\">[LeetCode] 146. LRU Cache</a>\n- <a target=\"_blank\" rel=\"noopener\" href=\"https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850\">Cracking the Coding Interview book by Gayle MacDowell</a>\n","wordCount":{"words":1010},"frontmatter":{"path":"/blog/design-lru-cache/","humanDate":"Jun 16, 2021","fullDate":"2021-06-16","title":"Design LRU Cache","keywords":["algorithmic coding","data structures","python"],"includeMath":null,"excerpt":"Have fun designing least-recently-used cache in Python","cover":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQP/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABaLZh5iDP/8QAGRAAAgMBAAAAAAAAAAAAAAAAAgMAAREE/9oACAEBAAEFAq58jF6WQnks3Osyn//EABYRAQEBAAAAAAAAAAAAAAAAAAEQUf/aAAgBAwEBPwEdn//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/AYf/xAAaEAACAwEBAAAAAAAAAAAAAAAAARExURAh/9oACAEBAAY/Am27wiWWeVhnP//EABkQAAMBAQEAAAAAAAAAAAAAAAABETEhQf/aAAgBAQABPyFmxDusLYSm08DpV9NhTLnIjEf/2gAMAwEAAgADAAAAEKPv/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAEDAQE/ENYgt//EABYRAQEBAAAAAAAAAAAAAAAAAAEAUf/aAAgBAgEBPxBxC3//xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMVFxQZHR/9oACAEBAAE/EMT7XWh9hiwCSwOCOwBWCUbK+WuuHqLRDKJftgoF3if/2Q=="},"images":{"fallback":{"src":"/static/7a2b18b535412ccd4663e743ae4093de/5267c/kelly-sikkema-v9FQR4tbIq8-unsplash.jpg","srcSet":"/static/7a2b18b535412ccd4663e743ae4093de/7284f/kelly-sikkema-v9FQR4tbIq8-unsplash.jpg 750w,\n/static/7a2b18b535412ccd4663e743ae4093de/29ba9/kelly-sikkema-v9FQR4tbIq8-unsplash.jpg 1080w,\n/static/7a2b18b535412ccd4663e743ae4093de/c8896/kelly-sikkema-v9FQR4tbIq8-unsplash.jpg 1366w,\n/static/7a2b18b535412ccd4663e743ae4093de/5267c/kelly-sikkema-v9FQR4tbIq8-unsplash.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/7a2b18b535412ccd4663e743ae4093de/57584/kelly-sikkema-v9FQR4tbIq8-unsplash.webp 750w,\n/static/7a2b18b535412ccd4663e743ae4093de/984df/kelly-sikkema-v9FQR4tbIq8-unsplash.webp 1080w,\n/static/7a2b18b535412ccd4663e743ae4093de/4a276/kelly-sikkema-v9FQR4tbIq8-unsplash.webp 1366w,\n/static/7a2b18b535412ccd4663e743ae4093de/9c00f/kelly-sikkema-v9FQR4tbIq8-unsplash.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6666666666666666}}},"coverCredits":"Photo by <a href=\"https://unsplash.com/@kellysikkema\">Kelly Sikkema</a> on <a href=\"https://unsplash.com/s/photos/draw-on-paper\">Unsplash</a>"}}},"pageContext":{"prevThought":{"frontmatter":{"path":"/blog/nature-of-distributed-systems/","title":"The Nature of Distributed Systems"}},"nextThought":{"frontmatter":{"path":"/blog/heapify/","title":"Heapify ✌️"}}}},"staticQueryHashes":["1271460761","1546741752","3019904396"]}